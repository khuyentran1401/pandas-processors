<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pandas_processors.create API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandas_processors.create</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from typing import Callable, Optional

import numpy as np
import pandas as pd
from sklearn.base import BaseEstimator, OneToOneFeatureMixin, TransformerMixin


class SumFeatures(BaseEstimator, TransformerMixin, OneToOneFeatureMixin):
    &#34;&#34;&#34;
    A scikit-learn compatible transformer that sums multiple features into a new feature.

    Parameters
    ----------
    features : list[str]
        The list of feature names to be summed.
    new_feature_name : str
        The name of the new feature created by summing the input features.
    drop_original : bool, optional
        Whether to drop the original features after creating the new feature. Default is False.
    weights : list[float], optional
        The weights to be applied to each feature during the summation. If None, all features&#39;s weights are 1.
        If provided, the length of weights must be the same as the length of features.

    Examples
    --------

    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from pandas_processors.create import SumFeatures
    &gt;&gt;&gt; X = pd.DataFrame({&#34;col1&#34;: [1, 2, 3], &#34;col2&#34;: [1, 1, 1], &#34;col3&#34;: [2, 2, 2]})
    &gt;&gt;&gt; sum_feature = SumFeatures(
    ...             features=[&#34;col1&#34;, &#34;col2&#34;, &#34;col3&#34;],
    ...             new_feature_name=&#34;col4&#34;,
    ...             weights=[1, 2, 0.5],
    ...         )
    &gt;&gt;&gt; sum_feature.fit_transform(X)
       col1  col2  col3  col4
    0     1     1     2   4.0
    1     2     1     2   5.0
    2     3     1     2   6.0
    &#34;&#34;&#34;

    def __init__(
        self,
        features: list[str],
        new_feature_name: str,
        drop_original: bool = False,
        weights: Optional[list[float]] = None,
    ) -&gt; None:
        self.features = features
        self.new_feature_name = new_feature_name
        self.drop_original = drop_original
        self.weights = weights

    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):
        &#34;&#34;&#34;
        Fit the transformer to the input data.

        Parameters
        ----------
        X : pd.DataFrame
            The training dataset.
        y : Optional[pd.Series], optional
            The label, by default None

        Returns
        -------
        self
            Returns the transformer instance.
        &#34;&#34;&#34;
        return self

    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Transform the input data by summing the specified features into a new feature.

        Parameters
        ----------
        X : pd.DataFrame
            The input DataFrame containing the data to be processed.

        Returns
        -------
        pd.DataFrame
            The input DataFrame with a new feature created by summing the specified features.
        &#34;&#34;&#34;
        X = X.copy()
        weights = self._get_weights()
        X[self.new_feature_name] = np.dot(X[self.features], weights)
        if self.drop_original:
            X.drop(columns=self.features, inplace=True)
        return X

    def _get_weights(self) -&gt; list[float]:
        &#34;&#34;&#34;
        Get the weights to be applied to each feature during the summation.

        Returns
        -------
        list[float]
            The weights to be applied to each feature.
        &#34;&#34;&#34;
        if self.weights is None:
            weights_ = [1.0] * len(self.features)
        else:
            if len(self.weights) != len(self.features):
                raise ValueError(
                    &#34;The length of weights must be the same as the length of features.&#34;
                )
            weights_ = self.weights
        return weights_


class ConditionalFeatures(BaseEstimator, TransformerMixin, OneToOneFeatureMixin):
    &#34;&#34;&#34;
    A scikit-learn compatible transformer that creates new features based on a condition applied to existing features.

    Parameters
    ----------
    features : str | list[str]
        The name(s) of the feature(s) to apply the condition to.
    condition : callable
        A callable object or function that defines the condition to be applied to each value in the features.
        The condition should return True or False.
    true_value : int | float | str
        The value to assign to the new feature(s) when the condition is True.
    false_value : int | float | str
        The value to assign to the new feature(s) when the condition is False.
    new_feature_names : str | list[str]
        The name(s) of the new feature(s) created by applying the condition.
        If a single name is provided, it will be used for all new features.
        If a list of names is provided, it must have the same length as the features.
    drop_original : bool, optional
        Whether to drop the original features after creating the new features. Default is False.

    Examples
    --------

    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from pandas_processors.create import ConditionalFeatures
    &gt;&gt;&gt; X = pd.DataFrame({&#34;col1&#34;: [-1, 2, 3], &#34;col2&#34;: [4, -5, 6]})
    &gt;&gt;&gt; # Use ConditionalFeatures with one feature
    &gt;&gt;&gt; conditional_feature = ConditionalFeatures(
    ...             features=&#34;col1&#34;,
    ...             new_feature_names=&#34;col3&#34;,
    ...             condition=lambda x: x &gt; 0,
    ...             true_value=1,
    ...             false_value=0,
    ...         )
    &gt;&gt;&gt; conditional_feature.fit_transform(X)
       col1  col2  col3
    0    -1     4     0
    1     2    -5     1
    2     3     6     1
    &gt;&gt;&gt; # Use ConditionalFeatures with multiple features
    &gt;&gt;&gt; conditional_feature = ConditionalFeatures(
    ...             features=[&#34;col1&#34;, &#34;col2&#34;],
    ...             new_feature_names=[&#34;col3&#34;, &#34;col4&#34;],
    ...             condition=lambda x: x &gt; 0,
    ...             true_value=1,
    ...             false_value=0,
    ...         )
    &gt;&gt;&gt; conditional_feature.fit_transform(X)
       col1  col2  col3  col4
    0    -1     4     0     1
    1     2    -5     1     0
    2     3     6     1     1
    &#34;&#34;&#34;

    def __init__(
        self,
        features: str | list[str],
        condition: Callable,
        true_value: int | float | str,
        false_value: int | float | str,
        new_feature_names: str | list[str],
        drop_original: bool = False,
    ) -&gt; None:
        if isinstance(features, str):
            features = [features]
        if isinstance(new_feature_names, str):
            new_feature_names = [new_feature_names]
        if len(features) != len(new_feature_names):
            raise ValueError(
                &#34;The length of features and new_feature_names must be the same.&#34;
            )
        self.features = features
        self.condition = condition
        self.true_value = true_value
        self.false_value = false_value
        self.new_feature_names = new_feature_names
        self.drop_original = drop_original

    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):
        &#34;&#34;&#34;
        Fit the transformer to the input data.

        Parameters
        ----------
        X : pd.DataFrame
            The training dataset.
        y : Optional[pd.Series], optional
            The label, by default None

        Returns
        -------
        self
            Returns the transformer instance.
        &#34;&#34;&#34;
        return self

    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Transform the input data by applying the condition to create new features.

        Parameters
        ----------
        X : pd.DataFrame
            The input DataFrame containing the data to be processed.

        Returns
        -------
        pd.DataFrame
            The input DataFrame with new features created by applying the condition.
        &#34;&#34;&#34;
        X = X.copy()

        X[self.new_feature_names] = X[self.features].map(
            lambda x: self.true_value if self.condition(x) else self.false_value
        )
        if self.drop_original:
            X.drop(columns=self.features, inplace=True)
        return X


if __name__ == &#34;__main__&#34;:
    import doctest

    doctest.testmod()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pandas_processors.create.ConditionalFeatures"><code class="flex name class">
<span>class <span class="ident">ConditionalFeatures</span></span>
<span>(</span><span>features: str | list[str], condition: Callable, true_value: int | float | str, false_value: int | float | str, new_feature_names: str | list[str], drop_original: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A scikit-learn compatible transformer that creates new features based on a condition applied to existing features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>str | list[str]</code></dt>
<dd>The name(s) of the feature(s) to apply the condition to.</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code>callable</code></dt>
<dd>A callable object or function that defines the condition to be applied to each value in the features.
The condition should return True or False.</dd>
<dt><strong><code>true_value</code></strong> :&ensp;<code>int | float | str</code></dt>
<dd>The value to assign to the new feature(s) when the condition is True.</dd>
<dt><strong><code>false_value</code></strong> :&ensp;<code>int | float | str</code></dt>
<dd>The value to assign to the new feature(s) when the condition is False.</dd>
<dt><strong><code>new_feature_names</code></strong> :&ensp;<code>str | list[str]</code></dt>
<dd>The name(s) of the new feature(s) created by applying the condition.
If a single name is provided, it will be used for all new features.
If a list of names is provided, it must have the same length as the features.</dd>
<dt><strong><code>drop_original</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to drop the original features after creating the new features. Default is False.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from pandas_processors.create import ConditionalFeatures
&gt;&gt;&gt; X = pd.DataFrame({&quot;col1&quot;: [-1, 2, 3], &quot;col2&quot;: [4, -5, 6]})
&gt;&gt;&gt; # Use ConditionalFeatures with one feature
&gt;&gt;&gt; conditional_feature = ConditionalFeatures(
...             features=&quot;col1&quot;,
...             new_feature_names=&quot;col3&quot;,
...             condition=lambda x: x &gt; 0,
...             true_value=1,
...             false_value=0,
...         )
&gt;&gt;&gt; conditional_feature.fit_transform(X)
   col1  col2  col3
0    -1     4     0
1     2    -5     1
2     3     6     1
&gt;&gt;&gt; # Use ConditionalFeatures with multiple features
&gt;&gt;&gt; conditional_feature = ConditionalFeatures(
...             features=[&quot;col1&quot;, &quot;col2&quot;],
...             new_feature_names=[&quot;col3&quot;, &quot;col4&quot;],
...             condition=lambda x: x &gt; 0,
...             true_value=1,
...             false_value=0,
...         )
&gt;&gt;&gt; conditional_feature.fit_transform(X)
   col1  col2  col3  col4
0    -1     4     0     1
1     2    -5     1     0
2     3     6     1     1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConditionalFeatures(BaseEstimator, TransformerMixin, OneToOneFeatureMixin):
    &#34;&#34;&#34;
    A scikit-learn compatible transformer that creates new features based on a condition applied to existing features.

    Parameters
    ----------
    features : str | list[str]
        The name(s) of the feature(s) to apply the condition to.
    condition : callable
        A callable object or function that defines the condition to be applied to each value in the features.
        The condition should return True or False.
    true_value : int | float | str
        The value to assign to the new feature(s) when the condition is True.
    false_value : int | float | str
        The value to assign to the new feature(s) when the condition is False.
    new_feature_names : str | list[str]
        The name(s) of the new feature(s) created by applying the condition.
        If a single name is provided, it will be used for all new features.
        If a list of names is provided, it must have the same length as the features.
    drop_original : bool, optional
        Whether to drop the original features after creating the new features. Default is False.

    Examples
    --------

    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from pandas_processors.create import ConditionalFeatures
    &gt;&gt;&gt; X = pd.DataFrame({&#34;col1&#34;: [-1, 2, 3], &#34;col2&#34;: [4, -5, 6]})
    &gt;&gt;&gt; # Use ConditionalFeatures with one feature
    &gt;&gt;&gt; conditional_feature = ConditionalFeatures(
    ...             features=&#34;col1&#34;,
    ...             new_feature_names=&#34;col3&#34;,
    ...             condition=lambda x: x &gt; 0,
    ...             true_value=1,
    ...             false_value=0,
    ...         )
    &gt;&gt;&gt; conditional_feature.fit_transform(X)
       col1  col2  col3
    0    -1     4     0
    1     2    -5     1
    2     3     6     1
    &gt;&gt;&gt; # Use ConditionalFeatures with multiple features
    &gt;&gt;&gt; conditional_feature = ConditionalFeatures(
    ...             features=[&#34;col1&#34;, &#34;col2&#34;],
    ...             new_feature_names=[&#34;col3&#34;, &#34;col4&#34;],
    ...             condition=lambda x: x &gt; 0,
    ...             true_value=1,
    ...             false_value=0,
    ...         )
    &gt;&gt;&gt; conditional_feature.fit_transform(X)
       col1  col2  col3  col4
    0    -1     4     0     1
    1     2    -5     1     0
    2     3     6     1     1
    &#34;&#34;&#34;

    def __init__(
        self,
        features: str | list[str],
        condition: Callable,
        true_value: int | float | str,
        false_value: int | float | str,
        new_feature_names: str | list[str],
        drop_original: bool = False,
    ) -&gt; None:
        if isinstance(features, str):
            features = [features]
        if isinstance(new_feature_names, str):
            new_feature_names = [new_feature_names]
        if len(features) != len(new_feature_names):
            raise ValueError(
                &#34;The length of features and new_feature_names must be the same.&#34;
            )
        self.features = features
        self.condition = condition
        self.true_value = true_value
        self.false_value = false_value
        self.new_feature_names = new_feature_names
        self.drop_original = drop_original

    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):
        &#34;&#34;&#34;
        Fit the transformer to the input data.

        Parameters
        ----------
        X : pd.DataFrame
            The training dataset.
        y : Optional[pd.Series], optional
            The label, by default None

        Returns
        -------
        self
            Returns the transformer instance.
        &#34;&#34;&#34;
        return self

    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Transform the input data by applying the condition to create new features.

        Parameters
        ----------
        X : pd.DataFrame
            The input DataFrame containing the data to be processed.

        Returns
        -------
        pd.DataFrame
            The input DataFrame with new features created by applying the condition.
        &#34;&#34;&#34;
        X = X.copy()

        X[self.new_feature_names] = X[self.features].map(
            lambda x: self.true_value if self.condition(x) else self.false_value
        )
        if self.drop_original:
            X.drop(columns=self.features, inplace=True)
        return X</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</li>
<li>sklearn.utils._metadata_requests._MetadataRequester</li>
<li>sklearn.base.TransformerMixin</li>
<li>sklearn.utils._set_output._SetOutputMixin</li>
<li>sklearn.base.OneToOneFeatureMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandas_processors.create.ConditionalFeatures.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X: pd.DataFrame, y: Optional[pd.Series] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fit the transformer to the input data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The training dataset.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Optional[pd.Series]</code>, optional</dt>
<dd>The label, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>Returns the transformer instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):
    &#34;&#34;&#34;
    Fit the transformer to the input data.

    Parameters
    ----------
    X : pd.DataFrame
        The training dataset.
    y : Optional[pd.Series], optional
        The label, by default None

    Returns
    -------
    self
        Returns the transformer instance.
    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="pandas_processors.create.ConditionalFeatures.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X: pd.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the input data by applying the condition to create new features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The input DataFrame containing the data to be processed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The input DataFrame with new features created by applying the condition.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Transform the input data by applying the condition to create new features.

    Parameters
    ----------
    X : pd.DataFrame
        The input DataFrame containing the data to be processed.

    Returns
    -------
    pd.DataFrame
        The input DataFrame with new features created by applying the condition.
    &#34;&#34;&#34;
    X = X.copy()

    X[self.new_feature_names] = X[self.features].map(
        lambda x: self.true_value if self.condition(x) else self.false_value
    )
    if self.drop_original:
        X.drop(columns=self.features, inplace=True)
    return X</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pandas_processors.create.SumFeatures"><code class="flex name class">
<span>class <span class="ident">SumFeatures</span></span>
<span>(</span><span>features: list[str], new_feature_name: str, drop_original: bool = False, weights: Optional[list[float]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A scikit-learn compatible transformer that sums multiple features into a new feature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>The list of feature names to be summed.</dd>
<dt><strong><code>new_feature_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the new feature created by summing the input features.</dd>
<dt><strong><code>drop_original</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to drop the original features after creating the new feature. Default is False.</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>list[float]</code>, optional</dt>
<dd>The weights to be applied to each feature during the summation. If None, all features's weights are 1.
If provided, the length of weights must be the same as the length of features.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from pandas_processors.create import SumFeatures
&gt;&gt;&gt; X = pd.DataFrame({&quot;col1&quot;: [1, 2, 3], &quot;col2&quot;: [1, 1, 1], &quot;col3&quot;: [2, 2, 2]})
&gt;&gt;&gt; sum_feature = SumFeatures(
...             features=[&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;],
...             new_feature_name=&quot;col4&quot;,
...             weights=[1, 2, 0.5],
...         )
&gt;&gt;&gt; sum_feature.fit_transform(X)
   col1  col2  col3  col4
0     1     1     2   4.0
1     2     1     2   5.0
2     3     1     2   6.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SumFeatures(BaseEstimator, TransformerMixin, OneToOneFeatureMixin):
    &#34;&#34;&#34;
    A scikit-learn compatible transformer that sums multiple features into a new feature.

    Parameters
    ----------
    features : list[str]
        The list of feature names to be summed.
    new_feature_name : str
        The name of the new feature created by summing the input features.
    drop_original : bool, optional
        Whether to drop the original features after creating the new feature. Default is False.
    weights : list[float], optional
        The weights to be applied to each feature during the summation. If None, all features&#39;s weights are 1.
        If provided, the length of weights must be the same as the length of features.

    Examples
    --------

    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from pandas_processors.create import SumFeatures
    &gt;&gt;&gt; X = pd.DataFrame({&#34;col1&#34;: [1, 2, 3], &#34;col2&#34;: [1, 1, 1], &#34;col3&#34;: [2, 2, 2]})
    &gt;&gt;&gt; sum_feature = SumFeatures(
    ...             features=[&#34;col1&#34;, &#34;col2&#34;, &#34;col3&#34;],
    ...             new_feature_name=&#34;col4&#34;,
    ...             weights=[1, 2, 0.5],
    ...         )
    &gt;&gt;&gt; sum_feature.fit_transform(X)
       col1  col2  col3  col4
    0     1     1     2   4.0
    1     2     1     2   5.0
    2     3     1     2   6.0
    &#34;&#34;&#34;

    def __init__(
        self,
        features: list[str],
        new_feature_name: str,
        drop_original: bool = False,
        weights: Optional[list[float]] = None,
    ) -&gt; None:
        self.features = features
        self.new_feature_name = new_feature_name
        self.drop_original = drop_original
        self.weights = weights

    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):
        &#34;&#34;&#34;
        Fit the transformer to the input data.

        Parameters
        ----------
        X : pd.DataFrame
            The training dataset.
        y : Optional[pd.Series], optional
            The label, by default None

        Returns
        -------
        self
            Returns the transformer instance.
        &#34;&#34;&#34;
        return self

    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Transform the input data by summing the specified features into a new feature.

        Parameters
        ----------
        X : pd.DataFrame
            The input DataFrame containing the data to be processed.

        Returns
        -------
        pd.DataFrame
            The input DataFrame with a new feature created by summing the specified features.
        &#34;&#34;&#34;
        X = X.copy()
        weights = self._get_weights()
        X[self.new_feature_name] = np.dot(X[self.features], weights)
        if self.drop_original:
            X.drop(columns=self.features, inplace=True)
        return X

    def _get_weights(self) -&gt; list[float]:
        &#34;&#34;&#34;
        Get the weights to be applied to each feature during the summation.

        Returns
        -------
        list[float]
            The weights to be applied to each feature.
        &#34;&#34;&#34;
        if self.weights is None:
            weights_ = [1.0] * len(self.features)
        else:
            if len(self.weights) != len(self.features):
                raise ValueError(
                    &#34;The length of weights must be the same as the length of features.&#34;
                )
            weights_ = self.weights
        return weights_</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.utils._estimator_html_repr._HTMLDocumentationLinkMixin</li>
<li>sklearn.utils._metadata_requests._MetadataRequester</li>
<li>sklearn.base.TransformerMixin</li>
<li>sklearn.utils._set_output._SetOutputMixin</li>
<li>sklearn.base.OneToOneFeatureMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pandas_processors.create.SumFeatures.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X: pd.DataFrame, y: Optional[pd.Series] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fit the transformer to the input data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The training dataset.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Optional[pd.Series]</code>, optional</dt>
<dd>The label, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>Returns the transformer instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):
    &#34;&#34;&#34;
    Fit the transformer to the input data.

    Parameters
    ----------
    X : pd.DataFrame
        The training dataset.
    y : Optional[pd.Series], optional
        The label, by default None

    Returns
    -------
    self
        Returns the transformer instance.
    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="pandas_processors.create.SumFeatures.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X: pd.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Transform the input data by summing the specified features into a new feature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The input DataFrame containing the data to be processed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The input DataFrame with a new feature created by summing the specified features.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Transform the input data by summing the specified features into a new feature.

    Parameters
    ----------
    X : pd.DataFrame
        The input DataFrame containing the data to be processed.

    Returns
    -------
    pd.DataFrame
        The input DataFrame with a new feature created by summing the specified features.
    &#34;&#34;&#34;
    X = X.copy()
    weights = self._get_weights()
    X[self.new_feature_name] = np.dot(X[self.features], weights)
    if self.drop_original:
        X.drop(columns=self.features, inplace=True)
    return X</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandas_processors" href="index.html">pandas_processors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pandas_processors.create.ConditionalFeatures" href="#pandas_processors.create.ConditionalFeatures">ConditionalFeatures</a></code></h4>
<ul class="">
<li><code><a title="pandas_processors.create.ConditionalFeatures.fit" href="#pandas_processors.create.ConditionalFeatures.fit">fit</a></code></li>
<li><code><a title="pandas_processors.create.ConditionalFeatures.transform" href="#pandas_processors.create.ConditionalFeatures.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pandas_processors.create.SumFeatures" href="#pandas_processors.create.SumFeatures">SumFeatures</a></code></h4>
<ul class="">
<li><code><a title="pandas_processors.create.SumFeatures.fit" href="#pandas_processors.create.SumFeatures.fit">fit</a></code></li>
<li><code><a title="pandas_processors.create.SumFeatures.transform" href="#pandas_processors.create.SumFeatures.transform">transform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>